Clojure & Java Interop
About a year ago I got a phone call asking if I wanted to join another team at DRW. The team supports a (primarily) Java application, but the performance requirements would also allow it to be written in a higher level language. I'd been writing Clojure (basically) full-time at that point - so my response was simple: I'd love to join, but I'm going to want to do future development using Clojure.

A year later we still have plenty of Java, but the vast majority of the new code I add is Clojure. One of the big reasons I'm able to use Clojure so freely is the seamless interop with Java.

Execute Clojure from Java
Calling Clojure from Java is as simple as loading the .clj file and invoking a method from that file. I used the same example years ago, but I'll inline it here for simplicity.
; interop/core.clj
(ns interop.core)

(defn print-string [arg]
  (println arg))

// Java calling code
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");
note: examples from this blog entry are available in this git repo. The commit with the code from the previous example is available here and I'm running the example from the command line with:
lein jar && java -cp "interop-1.0.0.jar:lib/*" interop.Example
Execute Java from Clojure
At this point we have Java executing some Clojure code, and we also have Clojure using an object that was created in Java. Even though we're in Clojure we can easily call methods on any Java object.
(ns interop.core)

(defn print-string [arg]
  (println arg "is" (.length arg) "characters long"))
commit

The above code (using the length method of a String instance) produces the following output.
hello world is 11 characters long
Calling a Java method and passing in additional arguments is also easy in Clojure.
(ns interop.core)

(defn print-string [arg]
  (println (.replace arg "hello" "goodbye")))
commit

The above code produces the following output.
goodbye world
There are a few other things to know about calling Java from Clojure. The following examples show how to call static methods, use enums, and use inner classes.
(ns interop.core)

(defn print-string [arg]
  ;;; calling a static method
  (println (String/valueOf true))

  ;;; using an enum
  (println (java.util.concurrent.TimeUnit/SECONDS))

  ;;; using a Java nested (inner) class. Note, in Clojure you
  ;;; use a $ instead of a .
  (println (java.util.AbstractMap$SimpleEntry. "key" "val")))
commit

And, the output:
true
#< SECONDS>
#<SimpleEntry key=val>
Create Java objects in Clojure
When working with Clojure you'll likely want to interact with existing Java objects, but you'll probably also want to create new instances of Java objects. You might have noticed the dot at the end of Abstract$SimpleEntry. in the previous example - that's how you instruct Clojure to create an instance of a Java object. The following example shows the dot notation for calling a constructor of the String class.
(ns interop.core)

(defn print-string [arg]
  (println (String. arg)))
commit

At this point our output is back to the original output.
hello world
When creating Java objects it's often beneficial to know which Java interfaces the Clojure data structures implement. The following examples demonstrate how you can create Java objects while passing Clojure datastructures (and functions) as constructor arguments.
(ns interop.core)

(defn print-string [arg]
  ;;; pass a Clojure vector where Java expects a java.util.Collection
  (println (java.util.HashSet. ["1" "2"]))

  ;;; pass a Clojure map where Java expects a java.util.Map
  (println (java.util.LinkedHashMap. {1 "1" 2 "2"}))

  ;;; pass a Clojure function where Java expects a Runnable
  (println (Thread. (fn [] (println "clojure fns are runnables (and callables)")))))
commit

The output shows the constructed Java objects.
#<HashSet [2, 1]>
#<LinkedHashMap {1=1, 2=2}>
#<Thread Thread[Thread-1,5,main]>
Calling constructors in Clojure is very easy, but that's not always an option when creating a Java object. At times you will likely need to create an instance of a Java interface. Clojure provides both proxy and reify for creating instances of Java interfaces. The following example demonstrates the syntax for using either proxy or reify.
(ns interop.core)

(defn proxy-coll []
  (proxy [java.util.Collection] []
    (add [o]
         (println o)
         true)))

(defn reify-coll []
  (reify java.util.Collection
    (add [this o]
         (println o)
         (println this)
         true)))

(defn main []
  (.add (proxy-coll) "this string is printed on proxied.add")
  (.add (reify-coll) "this string is printed on reified.add"))
commit

note, I also changed Example.java (the details are available in the above linked commit). The syntax for proxy and reify are fairly similar, and both offer additional options that are worth looking into. The primary differences between these two simple examples are:
The proxy implementation requires an empty vector where we could specify constructor arguments (if this were an abstract class instead of an interface).
The arg list for all methods of reify will specify the reified instance as the first argument. In our example the Collection.add method only takes one argument, but in our reify we also get the instance of the collection.
You might have also noticed that both implementations of add have "true" at the end - in our example we're hard-coding the return value of add to always return true. The following output is the result of running the current example code.
this string is printed on proxied.add
this string is printed on reified.add
#<core$reify_coll$reify__11 interop.core$reify_coll$reify__11@556917ee>
It's worth reading the docs to determine whether you want proxy or reify; however, if you don't see a clear choice I would opt for reify.

Returning objects from Clojure to Java
Our current Example.java returns something from the call to invoke on the clojure.lang.Var that is returned from RT.var("interop.core", "main"), but we're ignoring it so we have no idea what's returned.* Let's change the code and return something on purpose.
// interop/Example.java
package interop;

import clojure.lang.RT;

public class Example {
    public static void main(String[] args) throws Exception {
        RT.loadResourceScript("interop/core.clj");
        System.out.println(RT.var("interop.core", "main").invoke());
    }
}

; interop/core.clj
(ns interop.core)

(defn main []
  {:a "1" :b "2"})
Running our changes produces the following output.
{:a "1", :b "2"}
commit 

At this point we are back in Java land after making a quick trip to Clojure to get a value. Returning most objects will be pretty straightforward; however, at some point you may want to return a Clojure function. This turns out to be fairly easy as well, since Clojure functions are instances of the IFn interface. The following code demonstrates how to return a Clojure function and call it from within Java.
// interop/Example.java
package interop;

import clojure.lang.RT;

public class Example {
    public static void main(String[] args) throws Exception {
        RT.loadResourceScript("interop/core.clj");
        clojure.lang.IFn f = (clojure.lang.IFn) RT.var("interop.core", "main").invoke();
        f.invoke("hello world");
    }
}

// interop/core.clj
(ns interop.core)

(defn main [] println)
commit

The above example returns the println function from interop.core/main and then invokes the println function from within Java. I only chose to pass one argument to invoke; however, the IFn.invoke method has various overrides to allow you to pass several arguments. The above code works, but it can be simplified to the following example.
package interop;

import clojure.lang.RT;

public class Example {
    public static void main(String[] args) throws Exception {
        clojure.lang.IFn f = (clojure.lang.IFn) RT.var("clojure.core", "println");
        f.invoke("hello world");
    }
}
commit

It seems like a fitting end that our final output is the same as our original output.
hello world
*actually, it's the last thing that's returned, or "true" for this specific case.
Posted by Jay Fields at 6:46 AM   
Email This
BlogThis!
Share to Twitter
Share to Facebook
Share to Pinterest

Labels: clojure, clojure functions, functions, java, java interop
5 comments:

tapichu1:42 PM
Thanks for the post, I'm just starting to learn Clojure and I was wondering how to execute Clojure from Java.

Would this be a good way of working with lazy sequences? 

RT.loadResourceScript("interop/core.clj");
clojure.lang.IFn nth = (clojure.lang.IFn) RT.var("clojure.core", "nth");
clojure.lang.IFn fib = (clojure.lang.IFn) RT.var("interop.core", "fib");
System.out.println(nth.invoke(fib, 30));

Oh and something you didn't mention that I like about Clojure & Java interop is the '..' macro to chain method calls:

(.. System (getProperties) (get "os.name"))

Cheers

Reply

jaycfields1:58 PM
@tapichu,
You're welcome. Thanks for commenting.

Your example code will work just fine - RT.var returns a clojure.lang.Var, which is also a IFn, so there's no issue there; however, since you're just passing fib into invoke (which takes an Object) I would just leave fib as a clojure.lang.Var or I'd define it as an Object. I can't see any reason to cast it to an IFn.

When I first started doing clojure I used ..; however, these days I use -> exclusively. I mean't to put that in the blog entry as well, but forgot. Thanks for the reminder. It's worth knowing both, but I prefer -> since it works for Java as well as Clojure. The equivalent version of your example would be:

(-> (System/getProperties) (.get "os.name"))

Cheers, Jay

Reply

dr10:19 PM
Hi,

In proxy vs. reify, I think it's worth mentioning that the main difference is that proxy allows you to sub-class existing classes, not just implement interfaces. You mostly need proxy when you're working with old, yucky, inheritance-heavy Java libs. Otherwise, reify is almost always a better choice because it doesn't mess with "this", and plays nicely with protocols as well as interfaces.

Cheers,

Dave

Reply

Hemppo6:31 AM

this is heavily outdated:

// Java calling code
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");

Use this: // Java calling code
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");

Reply

Hemppo6:33 AM
this is heavily outdated:

// Java calling code
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");

Use this: // Java calling code
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");

Reply

********************************************************************************************
I often see people trying to call Clojure code from Java and having some trouble doing this. So I decided to write a quick utility to do this (inspired by Rich Hickey’s Lightening Talk), and provide a simple example.


The idea is that we use clojure.lang.RT to get access to the key functions that we need to call compile / Clojure code. We do this by setting up some static final variables in Java of type clojure.lang.Var, which we can then invoke to get the required behaviour from Clojure. Setting up these vars looks like this:

1
2
3
4
5
6
7
8
9
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Var;
...
public class Clojure {
 ...
 public static final Var REQUIRE=RT.var("clojure.core", "require");
 ...
}
Once we have the REQUIRE var available, we can invoke it to load any Clojure namespace we need, using code like below:

1
2
3
4
5
6
7
public static Object require(String nsName) {
  return REQUIRE.invoke(Symbol.intern(nsName));
}
 
static {
  require("my.special.namespace");
}
I’ve wrapped all this functionality up into a little utility class mikera.cljutils.Clojure, so you can write quick and easy Java apps that call into Clojure as below:

1
2
3
4
5
6
7
8
9
10
import mikera.cljutils.Clojure;
 
public class DemoApp {
  public static void main(String [] args) {
    String s = "(+ 1 2)";
    System.out.println("Evaluating Clojure code: "+s);
    Object result=Clojure.eval(s);
    System.out.println("=> "+ result);
  }
}
The utility is available here:

– GitHub site: https://github.com/mikera/clojure-utils

– Compiled version on Clojars: https://clojars.org/net.mikera/clojure-utils

